---
title: "Estimate Robustness of Real Networks"
output: html_notebook
author: Andrew L Jackson, Jean-Francois Arnoldi, Sam P. Ross & Ian Donohue
date: "`r format(Sys.time(), '%d %B %Y')`"
---


```{r setup}
library(tidyverse)
library(furrr) # for parallel implmenetation of purrr
```

## Import the Web of Life data

Loop over the datasets and import them into a list.

```{r import-webs}

# get all file names in the folder data/
all_files <- dir("data/")

# find the indices that are README or reference files
remove_these <- c(grep("README", all_files), grep("references", all_files))

# remove them from the vector of names and prepend the data/ folder address
all_web_files <- paste0("data/", all_files[-remove_these])

# import all the webs and covert then to binary association form
all_webs <- map(all_web_files, ~sign(read.csv(.x)))

# add names to each of the list entries. Required by map()
names(all_webs) <- all_web_files

# a table of all the webs by type
n_types <- table(unlist(map(names(all_webs), ~substr(.x, 8, 9))))


```


We used all the available bipartite webs from [http://www.web-of-life.es](Web of Life) as downloaded on 18 Febrary 2020. These comprise:

+ AF = Anemone-Fish (n = `r n_types["AF"]`)
+ HP = Host-Parasite (n = `r n_types["HP"]`)
+ PA = Plant-Ant (n = `r n_types["PA"]`)
+ PH = Plant-Herbivore (n = `r n_types["PH"]`)
+ PL = Plant-Pollinator (n = `r n_types["PL"]`)
+ SD = Seed dispersal (n = `r n_types["SD"]`)



## Summary statistics

### Define some functions that we will use to generate summary statics

A function to calculate complexity for a given web. 

```{r complexity-function}

complexityEstimate <- function(A) {
  
  # rows are traits
  N <- nrow(A)
  
  # columns are species
  S <- ncol(A)
  
  # original complexity estimate
  c <- (N / sum(A)) * log(S)
  
  # new complexity estimate 3/Feb/2020
  # c <- N * log(N) / sum(A)
  
  # 6/feb/2020 
  log_q <- -log ( (S * N - sum(A)) / (S * N))
  c <- (1/S) * (log(N) / log_q)
  
  
}

```

A function to calculate the robustness of a given web.

```{r robustness-function}

robustness <- function(Aperm, S = ncol(Aperm)){
  
   # number of Species
  # S <- ncol(Aperm)
  
  # number of traits
  # N <- nrow(Aperm)
  
  nn <- 0
  mm <- 0
  
  while (mm==0 & nn <= S) {
    nn <- nn + 1
    # mm <- min(rowSums( matrix(Aperm[, 1:nn], nrow = N, ncol = nn) ))
    mm <- min(rowSums( as.matrix(Aperm[, 1:nn])))
  }
  
  return( (S-nn+1) / (S * 1.0))
}

```

A function to take a given web, repeatedly resample it and remove species until it breaks. This lets us create an estimate of the mean robustness of a given web given random extinctions.

```{r resample-robustness}

shuffleExinctionSingle <- function(A, S) {
  
  # generate a permuation for species in A
  species <- sample(S)
  
  # premute within rows
  Aperm <- A[,species]
  
  # calculate robustness
  rob <- robustness(Aperm)
  
  return(rob)
  
}

sampleRobustness <- function(A, S = ncol(A), nb = 10){
  
  # number of Species
  # S <- ncol(A)
  
  # no longer need to prep this as we use map()
  # vector of results
  # res <- numeric(nb)
  
  # loop over replicates using parallel furrr map function.
  res <- future_map_dbl(1:nb, ~shuffleExinctionSingle( A, S))
  
  
  # for (k in 1:nb) {
  #   
  #   rob <- shuffleExinctionSingle(A = A, S = S)
  #   
  #   res[k] <- rob
  #   
  # }
  
  # return the mean of the results vector which is mean of 
  return(mean(res))  
  
}

```

### Apply our functions to each web

Calculate some summary statistics on each web and conver to data.frame format.

```{r summary-statistics}



df_webs <-  all_webs %>% 
  map_df(~data.frame(S = as.numeric(ncol(.x)),
                     N = as.numeric(nrow(.x)),
                     sum_A = as.numeric(sum(.x)),
                     min_S_per_N = min(rowSums(.x)),
                     var_S_per_N = var(rowSums(.x)),
                     mean_S_per_N = mean(rowSums(.x)),
                     est_p = sum(.x) / (ncol(.x) * nrow(.x)),
                     complexity = complexityEstimate(.x)
                     )
         )

# calculate dispersion, where the expected value according to the binomial 
# distributio is 1.
df_webs <- df_webs %>% mutate(dispersion = var_S_per_N / mean_S_per_N * (1 / 1 - est_p))


 # test_traits[i] <- min(rowSums(tmp))
 #  var_traits[i] <- var(rowSums(tmp))
 #  mean_traits[i] <- mean(rowSums(tmp))
 #  est_p[i] <- sum(tmp) / (res_S[i] * res_N[i])
 #  dispersion_test[i] <- (var_traits[i] / mean_traits[i]) * (1/(1-est_p[i]))
  
  
# print(df)

```

## Simulate Extinctions to calculate robustness

```{r simulate-extinctions}

# set up the multicore for the function sampleRobustness which calls them.
# im not sure if i should do this within sampleRobustness or if its ok to 
# do it once here outside.
plan(multisession(workers = 3))

do_robustness <- FALSE

if (do_robustness == TRUE ) {
  
  robustness_results <- all_webs %>% 
    map_dbl(~sampleRobustness(.x, nb = 500))
  
  save(robustness_results, file = "robustness_run.rda", compress = "xz")

  
}

if (do_robustness == FALSE){
  print("NB sampling for robustness not run. Loaded instead from previous run.")
  load("robustness_run.rda")
}

# Add the robustness estimate to the data.frame and 
# calcuate the residual to Jeff's model
df_webs <- df_webs %>% 
  mutate(robustness = robustness_results)

df_webs <- df_webs %>% 
  mutate(residual = 
           robustness - ( 0.7*exp(-3.5*complexity**2)+.3*exp(-0.8*complexity))
         )

# add labels for each type of web
df_webs <- df_webs %>% mutate(type = unlist(map(names(all_webs), ~substr(.x, 8, 9))))


```



## Plot results

```{r create-a-df-for-jeffs-model}

new_c <- seq(0, 2.5, length = 100)

# original approximation
# est_r <- 0.7*exp(-3.5*new_c**2)+.3*exp(-0.8*new_c)

# new approximation 3/Feb/2020
N_vec <- 30
beta <- 1.3
est_r <-  (N_vec * (exp(-new_c - beta * new_c ^ 2 )) )  / (N_vec + 1)

fit_df <- data.frame(new_c = new_c, 
                     est_r = est_r)


```


```{r}

g1 <- ggplot(df_webs %>% filter(N <= Inf), aes(x = complexity,
                     y = robustness,
                     color = log10(dispersion))) + 
  geom_point() + 
  scale_color_viridis_c() + 
  geom_line(data = fit_df, mapping = aes(x = new_c, y = est_r, color = NULL))

print(g1)

ggsave(g1,filename = "robust-complexity.jpeg", width = 10, height = 7)

```

```{r residuals-to-estimated-line}

g2 <- ggplot(df_webs, aes(x = complexity,
                     y = residual,
                     color = log10(dispersion))) + 
  geom_point() + 
  scale_color_viridis_c() + 
  geom_hline(yintercept = 0)
print(g2)

ggsave(g2,filename = "resid-complexity.jpeg", width = 10, height = 7)

```

```{r}

g3 <- ggplot(df_webs, aes(x = log10(dispersion),
                     y = residual,
                     color = log10(dispersion))) + 
  geom_point(aes(shape = type)) + 
  scale_color_viridis_c() + 
  geom_hline(yintercept = 0) + 
  labs(color = expression(log[10](dispersion)), 
       shape = "Web Type")
      
print(g3)

ggsave(g3,filename = "resid-dispersion.jpeg", width = 10, height = 7)

```


```{r}

g4 <- ggplot(df_webs, aes(x = log10(dispersion),
                     y = residual,
                     color = type)) + 
  geom_point(aes(shape = type), size = 2) + 
  scale_color_viridis_d() + 
  geom_hline(yintercept = 0) + 
  labs(color = expression(log[10](dispersion)), 
       shape = "Web Type")
      
print(g4)

# ggsave(g4,filename = "resid-dispersion.jpeg", width = 10, height = 7)

```


```{r}

g5 <- ggplot(df_webs %>% filter(N <= Inf), aes(x = complexity,
                     y = robustness,
                     color = type)) + 
  geom_point(aes(shape = type), size = 4) + 
  scale_color_viridis_d() + 
  geom_line(data = fit_df, mapping = aes(x = new_c, y = est_r, color = NULL))

print(g5)

# ggsave(g5,filename = "robust-complexity.jpeg", width = 10, height = 7)

```

## Fit linear models

We can fit some linear models to calculate the $R^2$ values of the various explanatory variables of robustness.

```{r}

N_vec <- 30
beta <- 1.3

df_webs <- df_webs %>% mutate(robustness_hat = (N_vec * 
                               (exp(-complexity - beta * complexity ^ 2 )) )  / 
                               (N_vec + 1))

# analytical_model <-  with( df_webs, 
#                            {(N_vec * 
#                                (exp(-complexity - beta * complexity ^ 2 )) )  / 
#                                (N_vec + 1)}
#                            )


# null model
m0 <- lm(robustness ~1, 
         data = df_webs %>% filter(!is.na(dispersion) & 
                                            (dispersion > 0)))

# model as above with analytical model as offset
m1 <- lm(robustness ~ -1, 
         offset =  robustness_hat, 
         data = df_webs %>% filter(!is.na(dispersion) & 
                                            (dispersion > 0)))

# model as above including log10(dispersion) as covariate
m2 <- lm(robustness ~ I(log10(dispersion)), 
         offset =  robustness_hat, 
         data = df_webs %>% filter(!is.na(dispersion) & 
                                            (dispersion > 0)))

# model as above including web type as covariate
m3 <- lm(robustness ~ I(log10(dispersion)) + factor(type), 
         offset =  robustness_hat, 
         data = df_webs %>% filter(!is.na(dispersion) & 
                                            (dispersion > 0)))



```


```{r}

```


