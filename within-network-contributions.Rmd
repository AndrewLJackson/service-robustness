---
title: "Within Network Species Contribution to Robustness"
output: html_notebook
---


```{r setup}

library(tidyverse)
library(magrittr)
library(furrr) # for parallel implmenetation of purrr

```


Objectives:

- test whether change in fragility and robustness are correlated across loss of individual species of a network


```{r}

# load the network
# "data/M_PL_062.csv" is the largest and also has one of the lowest residuals off the exp(-fstar - fstar^2) line
# "data/M_SD_022.csv" is more manageable with 110 species and a very low residual
# "data/M_PL_031.csv"   fstar = 1.23, S = 49
# "data/M_PL_046.csv" has low fragility fstar~= 0.2 and S=44
# "data/A_PH_007.csv" has fstar=0.16 and S=64
# "data/M_SD_016.csv" has fstar=0.2 and S=61
this_file <- "data/M_SD_016.csv"

net_data <- sign(read.csv(this_file)) %>% as.matrix()

```





## Summary statistics

### Define some functions that we will use to generate summary statics

A function to calculate our measure of fragility $f$, 

$$f= \frac{1}{S} \frac{\log(N)}{|\log(q)|}$$ 

where q=1-p and p is the connectance estimated as p~#links/(SxN).

```{r fragility}
fragilityEstimate <- function(A) {
  
  # rows are traits
  N <- nrow(A)
  
  # columns are species
  S <- ncol(A)
  
  # connectance measures
  p <- sum(A) / (S * N)
  q <-  1 - p
  
  # fragility
  # lines below are equivalent
  # f <- (1/S) * (log(N) / abs(log(q))) # alternative parameterisation
  f <- -log(N) / log(q) / S
  
  
  return(f)
  
}
```



A function to calculate the robustness of a given web, defined by its association matrix $\textbf{A}$ (whose elements $a_{ij} = \{0,1\}$) by simulating extinctions of species until at least one trait is lost, which owing to our assumption of $E^*=\text{AND}$ also equates to loss of the higher level service.

```{r robustness-function}

robustness <- function(Aperm, S = ncol(Aperm)){
  
  # ensure its a matrix
  Aperm <- as.matrix(Aperm)
  
  nn <- 0
  mm <- min(rowSums( as.matrix(Aperm[, 1:nn])))
  
  # move along columns from left to right until we lose a trait
  while (mm==0 && nn < S) {
    nn <- nn + 1
    mm <- min(rowSums( as.matrix(Aperm[, 1:nn])))
  }
  
  return( (S-nn+1) / (S * 1.0))
}

```

The function `shuffleExtinctionSingle()` takes a given empirical web, permute its columns, and calculate its robustness using the function `robustness` defined above. The function `sampleRobustness()` loops the call to `shuffleExtinctionSingle()` using parallel computing via the function `furr::future_map_dbl()` and returns the mean robustness across the defined number of replicates (we use `nb = 500` as defined later).

```{r resample-robustness}

shuffleExinctionSingle <- function(A, S) {
  
  # generate a permuation for species in A
  species <- sample(S)
  
  # premute within rows
  Aperm <- A[,species]
  
  # calculate robustness
  rob <- robustness(Aperm)
  
  return(rob)
  
}

sampleRobustness <- function(A, S = ncol(A), nb = 10){
  
  # loop over replicates using parallel furrr map function.
  res <- future_map_dbl(1:nb, ~shuffleExinctionSingle( A, S))
  
  # return the mean of the results vector which is mean of 
  
  R <- list()
  R$mu <- mean(res)
  R$Q025 <- quantile(res, 0.025)
  R$Q975 <- quantile(res, 0.975)
  return(R)  
  
}

# population variance
popVar <- function(x){
  
  x <- as.matrix(x)
  
  # number of rows, which is sample size
  n <- nrow(x)
  
  # compute and return population variance and correct it so it uses
  # n in place of n-1 as the demoninator.
  cov(x) *  (n - 1) / n
  
}

# dispersion
dispersion <- function(A){
  
  # population variance of species per trait
  var_S_per_N <-  popVar(rowSums(A))
  
  # mean of species per trait
  mean_S_per_N <- mean(rowSums(A))
  
  # p
  est_p <- sum(A) / (ncol(A) * nrow(A))
  
  # return dispersion
  return((var_S_per_N / mean_S_per_N) * (1 / 1 - est_p))
  
  
} 
```

A gaussian-exponential function to estimate robustness from fragility $R = \exp(-f - \frac{2}{3}x^2)$

```{r predict-robustness-from-fragility}

predictRobustness <- function(x) {exp(-x - (2/3)* x ^2 )}

```


## Loop over the network removing one species at a time


Calculate the stats on the full network.

```{r}

reps <- 100000

f_0 <- fragilityEstimate(net_data)

d_0 <- dispersion(net_data)

# apply the dispersion correction and ensure its positive by bouncing 
# as runif(n = 1, min = 0, max = 1)
# f_star_0 <- max(f_0 - (-0.2870702 * log10(d_0)), runif(1, 0, 0.1))
f_star_0 <- f_0 - (-0.2870702 * log10(d_0))

# estimate robustness by sampling
RR <- sampleRobustness(net_data, nb = reps)
R_0 <- RR$mu
R_0_025 <- RR$Q025
R_0_975 <- RR$Q975

```


Prime the results vectors for the removals.

```{r}
# use right assignment to make it easier to read
numeric(ncol(net_data)) -> f_res -> d_res -> f_star_res -> R_res

numeric(ncol(net_data)) -> sum_A_res -> S_res -> N_res -> R_res_025 -> R_res_975

```

Run over each species removal

```{r}

for (i in 1:ncol(net_data)) {
  
  # remove the ith column
  A <- net_data[,-i]
  
  # and calculate our metrics
  f_res[i] <- fragilityEstimate(A)
  d_res[i] <- dispersion(A)
  # f_star_res[i] <- max(f_res[i] + (-0.2870702 * log10(d_res[i])), runif(1, 0, 0.1))
  f_star_res[i] <- max(f_res[i] - (-0.2870702 * log10(d_res[i])), 0)
  RR <- sampleRobustness(A, nb = reps)
  R_res[i] <- RR$mu
  R_res_025[i]  <- RR$Q025
  R_res_975[i]  <- RR$Q975
  
  # some additional statistics for testing and debugging
  sum_A_res[i] <- sum(A)
  S_res[i] <- ncol(A)
  N_res[i] <- nrow(A)
  
  
}

# bundle into a data.frame

df_res <- data.frame(f_res = f_res, 
                     d_res = d_res, 
                     f_star_res = f_star_res, 
                     R_res = R_res,
                     sum_A_res = sum_A_res,
                     S_res = S_res,
                     N_res = N_res)

```

And plot

```{r}

g1 <- ggplot(data = df_res, mapping = aes(x = f_star_0 - f_star_res,
                                          y = R_0 - R_res)) + 
  geom_point() + 
  geom_smooth(method = "lm") + 
  ggtitle(this_file)  
  # geom_errorbar(aes(yCCmin = R_0 - (R_res_025), ymax = R_0 - (R_res_975)))
  # scale_x_log10() + 
  # scale_y_log10()

print(g1)

```


Which robustness values are higher in the leave-one-out networks?

```{r}

more_robust <- which(R_res > R_0)
  
df_res[more_robust, ]

```



